> ## 算法示例

- 搜罗到的算法题，无明显排序方式，自己手动实现一遍记录（长期更新）

### 排序

#### 冒泡排序

- 冒泡思想
- 拿当前项与后一项对比，比后项大交换位置否则不变
- 外轮循环 arr.length-1
- 这样每过一轮比较，当前数组中最大的就会放到末尾
- 内部需要循环 arr.lenth-1-第几次循环
- 图示：
  ![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16f09d8a2ce54a94a50b8bc829b751b7~tplv-k3u1fbpfcp-watermark.image)

```javascript
for (let i = 0; i < sort.length - 1; i++) {
  for (let j = 0; j < sort.length - 1 - i; j++) {
    if (sort[j] > sort[j + 1]) {
      [sort[j], sort[j + 1]] = [sort[j + 1], sort[j]];
    }
  }
}
```

- 冒泡排序时间复杂度最坏`O(n²)` 最好`O(n)`平均`O(n²)`空间复杂度`O(1)`

#### 快速排序

- 快排思想
- 拿到传入数组的中间项为基准
- 数组中比基准小的放左边数组，大的放右边数组
- 递归调用自身，然后做数组拼接
- 图示
  ![Quick Sort.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae77a03145b041388b19dc9698cb2086~tplv-k3u1fbpfcp-watermark.image)

```javascript
var nums = [2, 4, 1, 6, 3, 8, 3, 9, 4];
function quick(arr) {
  //    如果传进来的数组中只有一项，那么无需再排
  if (arr.length <= 1) {
    return arr;
  }
  // 第一步拿到传入数组的中间项序列;
  let flag = Math.floor(arr.length / 2);
  // 在原数组中移除并保存;
  let key = arr.splice(flag, 1)[0];
  let arrLeft = []; //存放比中间项小的数组
  let arrRight = []; //存放比中间项大的数组
  for (let i = 0; i < arr.length; i++) {
    let item = arr[i];
    // 比中间项大的放右边数组，小的放左边数组
    //如果加上相等判定，则可以用于数组去重
    item >= key ? arrRight.push(item) : arrLeft.push(item);
  }
  // 利用递归，左+中间项+右输出
  return quick(arrLeft).concat(key, quick(arrRight));
}
var newArr = quick(nums);
console.log(newArr); //[ 1, 2, 3, 3, 4, 4, 6, 8, 9 ]
```

- 快排时间复杂度最坏`O(n²)` 最好`O(nlog₂n)`平均`O(nlog₂n)`空间复杂度`O(nlog₂n)`

### 排序
