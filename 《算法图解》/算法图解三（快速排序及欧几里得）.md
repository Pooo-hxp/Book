> > `
> >
> > > > > ## 图解算法三
#### 快速排序——使用分而治之的策略
 结论：
 * 分而治之：一种著名的递归式问题解决思想
 * 欧几里得算法：又名辗转相除法，一种常见且实用的算法思想
 * **欧几里得算法**
    > 又名辗转相除法，是一种求最大公约数的常用方法
    >>方式：以较大数除以较小数，再用出现的余数（第一余数）去除除数，然后再用出现的余数（第二余数）去除第一余数，如此往复，直至余为0，最后的除数就是最大公约数
    >>>A除B相当于说是用B除以A，即：B/A

注：比如说求（25,10）-> （25/10=2余5）-> （10/5=0余0）则最大公约数是整除全最后一个除数为5。
***
   ### 欧几里得算法用代码实现如下
```
    function Euclid(x, y) {
        let r = x > y ? x % y : y % x;
        let min = x > y ? y : x;
        if (r == 0) {
            return min;
        } else {
            return Euclid(min, r)
        }
    }
/**简化版本 */
    function Euclid(a, b) {
        return b === 0 ? a : Euclid(b, a % b);
    }
    Euclid(25, 10)//--5
```
### 使用递归函数进行数组之和/数组中最大值等获取
```
    function getSum(arr) {
        /*
        if(arr.length>1){
            //每次递归都移出数组第一项，*1避免字符串拼接而非运算
            return arr.shift()*1+getSum(arr)*1
        }else{
            return arr[0]
        }
        */
        //上方代码可简写成如下形式
        return arr.length == 1 ? arr[0] : arr.shift() + getSum(arr)
    }
    var arr = [2, 4, 5, 7, 5, 6, 2, 3]
    getSum(arr)

    function getMax(max, arr) {
        if (arr.length > 1) {
            //当前最大值大于数组当前首项则保持，否则重新赋值
            max = max > arr[0] ? max : arr[0];
            arr.shift()
            return getMax(max, arr)
        } else
            return max
    }
    var arr2 = [2, 4, 5, 7, 5, 6, 2, 3]
    getMax(0, arr2)
```         
**快速排序**

1、算法的速度指的并非时间，而是操作数的增速。

2、谈论算法的速度时，说的是随着输入的增加，其运行时间将以什么样的速度增加。

3、算法的运行时间用大O表示法表示。

4、O(log n) 比 O(n)快，当需要搜索的元素越多时，前者比后者快得越多。
>原理：递归的实现是通过重复调用函数本身，而调用的时候每次都要保存局部变量、形参、返回值等，这些都会影响代码执行的效率。
#### **栈**：调用栈`（call stack）`在编程中是一个非常重要的概念。
  >  计算机在内部使用被称之为调用栈的栈
  >> 调用栈主要功能：保存调用的返回地址。
  - 举个例子
  ```

  ```
  1. 在这个函数中，调用Poo()时，计算机首先为该函数调用分配一块内存
  2. 比如使用这块内存，首先变量` name` 被设置成` potato`, 这需要存储在内存中
- 每当调用函数的时候，计算机都像这样把函数涉及到的变量值存储到内存内存中
   > 初始调用` Poo('potato')`
    - 执行`Poo`函数时,先赋值存储变量到内存中
    - 然后打印` Hi,I'M potato` 

  |    |   Poo  |                      
  | :---------:| :------------:| 
  |   name     |  potato|     
  | | | 
   > 再调用` getHobby(name)` 同样计算机也为它分配内存，第二个内存块位于第一个内存块上方 **（压栈）**


    |    |   getHobby  |                      
    | :---------:| :------------:| 
    |   name     |  potato|     
    |    |   Poo  |                      
    |   name     |  potato|     
    | | | 
   > ` getHobby(name)` 执行完毕，打印` 'potato的爱好是编程'` 函数调用返回，此时栈顶的内存块会弹出
   
    |    |   getHobby  |                      
    | :---------:| :------------:| 
    |   name     |  potato|    
  - *此时上方的内存块会分离* **(弹出)**

  |    |   Poo  |                      
  | :---------:| :------------:| 
  |   name     |  potato|     
  | | | 
     > 此时栈顶的函数是` Poo()` ,意味着返回到了函数` Poo('potato')` ，总体来看函数` Poo('potato')`只执行了一部分                      
  - **注：这是一个很重要的概念，在函数中调用另一个函数时，当前函数暂停，并处于未完成的状态，该函数的所有变量的值都还在内存中，如例子中一样，执行完` getHobby(name)`又回到了` Poo('potato')`，然后从离开的地方接着往下执行。**
   > 然后调用函数` Bye(name)` 在栈顶添加这个函数的内存块，重复上述步骤，执行打印后从栈顶弹出。

    |    |   Bye  |                      
    | :---------:| :------------:| 
    |   name     |  potato|     
    |    |   Poo  |                      
    |   name     |  potato|     
    | | | 
   > 这个栈用于存储多个函数的变量，因此被称之为`调用栈`
### 总结
> **由以上特性可知：**

-  递归在性能上并没有优势，只是代码更易解读而已。
-  在实际使用场景中调用栈有可能会很长将占用大量的内存，造成内存崩溃隐患